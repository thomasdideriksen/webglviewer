<!DOCTYPE html>

<html>

    <head>
        <meta charset='utf-8'>
        <title>Tiled Viewer Test</title>
        <style>
            html {
                width: 100%;
                height: 100%;
                margin: 0px;
                padding: 0px;
            }
            body {
                width: 100%;
                height: 100%;
                margin: 0px;
                padding: 0px;
                display: flex;
                background: #202020;
                justify-content: center;
                align-items: center;
            }
            #container {
                width: 80%;
                height: 60%;
                border: 1px solid white;
                overflow: hidden;
            }
        </style>
        <script>
            
            'use strict';
        
            //
            // Top level namespace
            //
            var IM = {};
            
            //
            // Animator
            //
            IM.Animator = function() {
                this._animations = {};
            }
            
            IM.Animator.prototype = {
                
                constructor: IM.Animator,
                
                start: function(name, to, duration) {
                    var animation = {
                        from: this.get(name),
                        to: to,
                        duration: duration,
                        t0: Date.now(),
                    };
                    this._animations[name] = animation;
                },
                
                set: function(name, value) {
                    this.start(name, value, 0);
                },
                
                finished: function() {
                    for (var key in this._animations) {
                        if (!this._animations[key].finished) {
                            return false;
                        }
                    }
                    return true;
                },
                
                get: function(name) {
                    var animation = this._animations[name];
                    if (!animation) {
                        return 0;
                    }
                    var dt = Date.now() - animation.t0;
                    var t = Math.min(1.0, dt / animation.duration);
                    if (t < 1.0) {
                        t = t - 1.0;
                        t = t * t * t + 1.0;
                        return animation.from + t * (animation.to - animation.from);
                    } else {
                        animation.finished = true;
                        return animation.to;
                    }
                },
            }
            
            //
            // 3x3 Matrix namespace
            //
            IM.Mat3 = {};
            
            IM.Mat3.makeIdentity = function() {
                return new Float32Array([
                    1, 0, 0, 
                    0, 1, 0, 
                    0, 0, 1]);
            }
            
            IM.Mat3.makeTranslation = function(tx, ty) {
                return new Float32Array([
                    1.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    tx,  ty,  1.0]);
            }
            
            IM.Mat3.makeScale = function(sx, sy) {
                return new Float32Array([
                    sx,  0.0, 0.0,
                    0.0, sy,  0.0,
                    0.0, 0.0, 1.0]);
            }
            
            IM.Mat3.makeRotation = function(rad) {
                var sin = Math.sin(rad);
                var cos = Math.cos(rad);
                return new Float32Array([
                    cos, -sin, 0.0,
                    sin,  cos, 0.0,
                    0.0,  0.0, 1.0]);
            }
            
            IM.Mat3.multiplyTwo = function(a, b) {
                var res = new Float32Array(9);
                    
                res[0] = a[0] * b[0] + a[3] * b[1] + a[6] * b[2];
                res[3] = a[0] * b[3] + a[3] * b[4] + a[6] * b[5];
                res[6] = a[0] * b[6] + a[3] * b[7] + a[6] * b[8];
                
                res[1] = a[1] * b[0] + a[4] * b[1] + a[7] * b[2];
                res[4] = a[1] * b[3] + a[4] * b[4] + a[7] * b[5];
                res[7] = a[1] * b[6] + a[4] * b[7] + a[7] * b[8];
                
                res[2] = a[2] * b[0] + a[5] * b[1] + a[8] * b[2];
                res[5] = a[2] * b[3] + a[5] * b[4] + a[8] * b[5];
                res[8] = a[2] * b[6] + a[5] * b[7] + a[8] * b[8];
                    
                return res;
            }
            
            IM.Mat3.multiply = function() {
                switch (arguments.length) {
                    case 0: return null;
                    case 1: return arguments[1];
                    default:
                        var res = IM.Mat3.multiplyTwo(arguments[0], arguments[1]);
                        for (var i = 2; i < arguments.length; i++) {
                            res = IM.Mat3.multiplyTwo(res, arguments[i]);
                        }
                        return res;
                }
            }
            
            IM.Mat3.transpose = function(a) {
                var res = new Float32Array(9);
                    
                res[0] = a[0];
                res[1] = a[3];
                res[2] = a[6];
                
                res[3] = a[1];
                res[4] = a[4];
                res[5] = a[7];
                
                res[6] = a[2];
                res[7] = a[5];
                res[8] = a[8];
                
                return res;
            }
            
            IM.Mat3.determinant = function(a) {
                // http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche23.html
                
                return a[0] * a[4] * a[8] +
                       a[1] * a[5] * a[6] +
                       a[2] * a[3] * a[7] -
                       a[0] * a[5] * a[7] -
                       a[2] * a[4] * a[6] -
                       a[1] * a[3] * a[8];
            }
            
            IM.Mat3.invert = function(a) {
                // http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche23.html
                
                var d = IM.Mat3.determinant(a);
                if (d == 0.0) {
                    throw 'Matrix is not invertible';
                }
                
                var s = 1.0 / d;
                var res = new Float32Array(9);
                
                res[0] = s * (a[4] * a[8] - a[7] * a[5]);
                res[3] = s * (a[6] * a[5] - a[3] * a[8]);
                res[6] = s * (a[3] * a[7] - a[6] * a[4]);
                
                res[1] = s * (a[7] * a[2] - a[1] * a[8]);
                res[4] = s * (a[0] * a[8] - a[6] * a[2]);
                res[7] = s * (a[6] * a[1] - a[0] * a[7]);
                
                res[2] = s * (a[1] * a[5] - a[4] * a[2]);
                res[5] = s * (a[3] * a[2] - a[0] * a[5]);
                res[8] = s * (a[0] * a[4] - a[3] * a[1]);
                
                return res;
            }
            
            //
            // Helpers namespace
            //
            IM.Helpers = {};
            
            //
            // XHR GET single
            //
            IM.Helpers.XHRGet = function(url, callback) {
                var request = new XMLHttpRequest();
                request.onload = function(e) {
                    callback(request.responseText);
                }
                request.onerror = function(e) {
                    callback(null);
                }
                request.open('GET', url);
                request.send();
            }
            
            //
            // XHR GET multiple
            //
            IM.Helpers.XHRGetMultiple = function(urls, callback) {
                var remaining = urls.length;
                var result = {};
                for (var i = 0; i < urls.length; i++) {
                    (function(url) {
                        IM.Helpers.XHRGet(url, function(data) {
                            result[url] = data;
                            remaining--;
                            if (remaining == 0) {
                                callback(result);
                            }
                        });
                    })(urls[i]);
                }
            }
            
            //
            // GL namespace
            //
            IM.GL = {};
            
            //
            // GL Program
            //
            IM.GL.Program = function(gl, vertexShaderCode, fragmentShaderCode) {
                this._uniforms = {};
                this._attributes = {};
                this._gl = gl;
                this._vertexShader = this._createShader(vertexShaderCode, gl.VERTEX_SHADER);
                this._fragmentShader = this._createShader(fragmentShaderCode, gl.FRAGMENT_SHADER);
                this._program = gl.createProgram();
                gl.attachShader(this._program, this._vertexShader);
                gl.attachShader(this._program, this._fragmentShader);
                gl.linkProgram(this._program);
                if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
                    throw gl.getProgramInfoLog(this._program);
                }
            }
            
            IM.GL.Program.prototype = {
            
                constructor: IM.GL.Program,
                
                _createShader: function(code, type) {
                    var gl = this._gl;
                    var shader = gl.createShader(type);
                    gl.shaderSource(shader, code);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        throw gl.getShaderInfoLog(shader);
                    }
                    return shader;
                },
                
                _findUniform: function(name) {
                    if (!(name in this._uniforms)) {
                        this._uniforms[name] = this._gl.getUniformLocation(this._program, name);
                        if (!this._uniforms[name]) {
                            throw 'Invalid uniform: ' + name;
                        }
                    }
                    return this._uniforms[name];
                },
                
                _findAttribute: function(name) {
                    if (!(name in this._attributes)) {
                        this._attributes[name] = this._gl.getAttribLocation(this._program, name);
                        if (!this._attributes[name] < 0) {
                            throw 'Invalid attribute: ' + name;
                        }
                    }
                    return this._attributes[name];
                },
                
                use: function() {
                    this._gl.useProgram(this._program);
                },
                
                getAttributeLocation: function(name) {
                    return this._findAttribute(name);
                },
                
                setUniform1f: function(name, value) {
                    this._gl.uniform1f(this._findUniform(name), value);
                },
                
                setUniform1i: function(name, value) {
                    this._gl.uniform1i(this._findUniform(name), value);
                },
                
                setUniformMatrix3fv: function(name, value) {
                    this._gl.uniformMatrix3fv(this._findUniform(name), false, value);
                },
            }
            
            //
            // Viewer
            //
            IM.Viewer = function(domContainer) {
                this._domContainer = domContainer;
                this._canvas = document.createElement('canvas');
                this._gl = this._canvas.getContext('webgl', { antialias: true });
                this._domContainer.appendChild(this._canvas);
                this._animator = new IM.Animator();
                this._aspectMatrix = IM.Mat3.makeIdentity();
                this._matrix = IM.Mat3.makeIdentity();
                this._resize();
                
                var context = this;
                window.addEventListener('resize', function() { context._resize(); });
            }
            
            IM.Viewer.prototype = {
                
                constructor: IM.Viewer,
                
                initialize: function(callback) {
                    var vertexShaderName = 'viewerVertexShader.glsl';
                    var fragmentShaderName = 'viewerFragmentShader.glsl';
                    var context = this;
                    IM.Helpers.XHRGetMultiple([vertexShaderName, fragmentShaderName], function(data) {
                        context._program = new IM.GL.Program(context._gl, data[vertexShaderName], data[fragmentShaderName]);
                        context._initialized = true;
                        if (callback) {
                            callback();
                        }
                    });
                },
                
                setImage: function(url, callback) {
                    var im = new Image();
                    var context = this;
                    im.onload = function() {
                        context._setImage(im);
                        if (callback) {
                            callback();
                        }
                    };
                    im.src = url;
                },
                
                _createQuad: function(x, y, w, h, texW, texH) {
                    return [x,     y,     0,    0,     // 0-2
                            x,     y + h, 0,    texH,  // |/
                            x + w, y,     texW, 0,     // 1
                            x,     y + h, 0,    texH,  //   2
                            x + w, y + h, texW, texH,  //  /|
                            x + w, y,     texW, 0];    // 0-1
                },
                
                _setImage: function(im) {
                    this._tiles = [];
                    var buffer = [];
                    var tileSize = 1024;
                    var roundPot = function(x) { return Math.pow(2.0, Math.ceil(Math.log(x) / Math.log(2.0))); }
                    for (var y = 0; y < im.height; y += tileSize) {
                        var height = Math.min(tileSize, im.height - y);
                        var heightPot = roundPot(height);
                        for (var x = 0; x < im.width; x += tileSize) {
                            var width = Math.min(tileSize, im.width - x);
                            var widthPot = roundPot(width);
                            
                            var tileIm = this._cropImage(im, x, y, widthPot, heightPot);
                            var tileTex = this._createTexture(tileIm);
                            this._tiles.push(tileTex);
                  
                            var quad = this._createQuad(x / tileSize, y / tileSize, width / tileSize, height / tileSize, width / widthPot, height / heightPot);
                            Array.prototype.push.apply(buffer, quad);
                        }
                    }
                    
                    this._program.use();
                    var gl = this._gl;
                    
                    // Create buffer
                    this._buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer), gl.STATIC_DRAW);
                    
                    // Enable and configure buffer
                    var bufferLocation = this._program.getAttributeLocation('PositionTexCoord');
                    gl.enableVertexAttribArray(bufferLocation);
                    gl.vertexAttribPointer(bufferLocation, 4, gl.FLOAT, false, 0, 0);
                    
                    this._invalidate();
                },
                
                _cropImage: function(im, x, y, width, height) {
                    var cvs = document.createElement('canvas');
                    cvs.width = width;
                    cvs.height = height;
                    var ctx = cvs.getContext('2d');
                    ctx.drawImage(im, x, y, width, height, 0, 0, width, height);
                    return cvs;
                },
                
                _createTexture: function(im) {
                    var gl = this._gl;
                    var tex = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, tex);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, im);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    return tex;
                },
                
                _resize: function() {
                    var style = window.getComputedStyle(this._domContainer);
                    var width = Math.ceil(parseFloat(style.width));
                    var height = Math.ceil(parseFloat(style.height));
                    this._canvas.width = width;
                    this._canvas.height = height;
                    this._gl.viewport(0, 0, width, height);
                    
                    var min = Math.min(width, height);
                    
                    var m0 = IM.Mat3.makeScale(1, -1);
                    var m1 = IM.Mat3.makeTranslation(-1, -1);
                    var m2 = IM.Mat3.makeScale(min / width, min / height);
                    
                    this._aspectMatrix = IM.Mat3.multiply(m0, m1, m2);
                    
                    this._invalidate();
                },
                
                _invalidate: function() {
                    if (!this._renderPending) {
                        this._renderPending = true;
                        var context = this;
                        requestAnimationFrame(function() {
                            var finished = context._render();
                            context._renderPending = false;
                            if (!finished) {
                                context._invalidate();
                            }
                        });
                    }
                },
                
                _render: function() {
                    console.log('render');
                    var gl = this._gl;
                    gl.clearColor(0.15, 0.15, 0.15, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    if (this._initialized) {
                    
                        this._matrix = IM.Mat3.makeRotation(0.0);
                        var matrix = IM.Mat3.multiply(this._aspectMatrix, this._matrix);
                        this._program.setUniformMatrix3fv('Matrix', matrix);
                        this._program.setUniform1i('Texture', 0);
                        gl.activeTexture(gl.TEXTURE0);
                        
                        for (var i = 0; i < this._tiles.length; i++) {
                            gl.bindTexture(gl.TEXTURE_2D, this._tiles[i]);
                            gl.drawArrays(gl.TRIANGLES, i * 6, 6);
                        }
                    }
                    return this._animator.finished();
                },
            }
            
            
            
            
            //
            // For testing purposes
            //
            function init() {            
                var domContainer = document.getElementById('container');
                var viewer = new IM.Viewer(domContainer);
                viewer.initialize(function() {
                    viewer.setImage('image.png');
                });
            }
        
        </script>
    </head>
    
    <body onload='init()'>
        <div id='container'></div>
    </body>

</html>