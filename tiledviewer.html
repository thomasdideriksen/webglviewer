<!DOCTYPE html>

<html>

    <head>
        <meta charset='utf-8'/>
        <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/>
        <link href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300" rel="stylesheet">
        <title>Tiled WebGL Image Viewer</title>
        <style>
            html {
                width: 100%;
                height: 100%;
                margin: 0px;
                padding: 0px;
            }
            body {
                width: 100%;
                height: 100%;
                margin: 0px;
                padding: 0px;
                display: flex;
                flex-flow: column nowrap;
                background: #202020;
            }
            #container {
                flex: 1 1 auto;
                overflow: hidden;
            }
            #controls {
                flex: 0 0 48px;
                display: flex;
                flex-flow: row nowrap;
                border-top: 1px solid #404040;
            }
            .control {
                flex: 0 0 75px;
                font-family: 'Open Sans Condensed', sans-serif;
                color: #808080;
                font-size: 0.9em;
                cursor: pointer;
                line-height: 48px;
                text-align: center;
                border-right: 1px solid #404040;
                text-transform: uppercase;
               -webkit-touch-callout: none;
               -webkit-user-select: none;
               -khtml-user-select: none;
               -moz-user-select: none;
               -ms-user-select: none;
                user-select: none;
                transition: background 0.15s ease-out;
            }
            .control:hover, .control:focus {
                background: rgba(255, 255, 255, 0.08);
            }
            .control:active {
                background: rgba(255, 255, 255, 0.16);
            }
        </style>

        <script>
            
            'use strict';
        
            //
            // Top level namespace
            //
            var IM = {};
            
            //
            // Animator
            //
            IM.Animator = function() {
                this._animations = {};
            }
            
            IM.Animator.prototype = {
                
                constructor: IM.Animator,
                
                start: function(name, to, duration) {
                    var animation = {
                        from: this.get(name),
                        to: to,
                        duration: duration,
                        t0: Date.now(),
                    };
                    this._animations[name] = animation;
                },
                
                set: function(name, value) {
                    this.start(name, value, 0);
                },
                
                finished: function() {
                    for (var key in this._animations) {
                        if (!this._animations[key].finished) {
                            return false;
                        }
                    }
                    return true;
                },
                
                getDestination: function(name) {
                    var animation = this._animations[name];
                    if (!animation) {
                        return 0;
                    }
                    return animation.to;
                },
                
                get: function(name) {
                    var animation = this._animations[name];
                    if (!animation) {
                        return 0;
                    }
                    var dt = Date.now() - animation.t0;
                    var t = Math.min(1.0, dt / animation.duration);
                    if (t < 1.0) {
                        t = t - 1.0;
                        t = -(t * t * t * t - 1.0);
                        return animation.from + t * (animation.to - animation.from);
                    } else {
                        animation.finished = true;
                        return animation.to;
                    }
                },
            }
            
            //
            // 3x3 Matrix namespace
            //
            IM.Mat3 = {};
            
            IM.Mat3.makeIdentity = function() {
                return new Float32Array([
                    1, 0, 0, 
                    0, 1, 0, 
                    0, 0, 1]);
            }
            
            IM.Mat3.makeTranslation = function(tx, ty) {
                return new Float32Array([
                    1.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    tx,  ty,  1.0]);
            }
            
            IM.Mat3.makeScale = function(sx, sy) {
                return new Float32Array([
                    sx,  0.0, 0.0,
                    0.0, sy,  0.0,
                    0.0, 0.0, 1.0]);
            }
            
            IM.Mat3.makeRotation = function(rad) {
                var sin = Math.sin(rad);
                var cos = Math.cos(rad);
                return new Float32Array([
                    cos, -sin, 0.0,
                    sin,  cos, 0.0,
                    0.0,  0.0, 1.0]);
            }
            
            IM.Mat3.multiplyTwo = function(a, b) {
                var res = new Float32Array(9);
                    
                res[0] = a[0] * b[0] + a[3] * b[1] + a[6] * b[2];
                res[3] = a[0] * b[3] + a[3] * b[4] + a[6] * b[5];
                res[6] = a[0] * b[6] + a[3] * b[7] + a[6] * b[8];
                
                res[1] = a[1] * b[0] + a[4] * b[1] + a[7] * b[2];
                res[4] = a[1] * b[3] + a[4] * b[4] + a[7] * b[5];
                res[7] = a[1] * b[6] + a[4] * b[7] + a[7] * b[8];
                
                res[2] = a[2] * b[0] + a[5] * b[1] + a[8] * b[2];
                res[5] = a[2] * b[3] + a[5] * b[4] + a[8] * b[5];
                res[8] = a[2] * b[6] + a[5] * b[7] + a[8] * b[8];
                    
                return res;
            }
            
            IM.Mat3.transformPoint = function(m, x, y) {
                var res = new Float32Array(2);
                
                res[0] = m[0] * x + m[3] * y + m[6];
                res[1] = m[1] * x + m[4] * y + m[7];
                
                return res;
            }
            
            IM.Mat3.multiply = function() {
                if (arguments.length < 2) {
                    throw 'Matrix multiply function needs two or more paramaters';
                }
                var res = IM.Mat3.multiplyTwo(arguments[0], arguments[1]);
                for (var i = 2; i < arguments.length; i++) {
                    res = IM.Mat3.multiplyTwo(res, arguments[i]);
                }
                return res;
            }
            
            IM.Mat3.transpose = function(a) {
                var res = new Float32Array(9);
                    
                res[0] = a[0];
                res[1] = a[3];
                res[2] = a[6];
                
                res[3] = a[1];
                res[4] = a[4];
                res[5] = a[7];
                
                res[6] = a[2];
                res[7] = a[5];
                res[8] = a[8];
                
                return res;
            }
            
            IM.Mat3.determinant = function(a) {
                // http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche23.html
                
                return a[0] * a[4] * a[8] +
                       a[1] * a[5] * a[6] +
                       a[2] * a[3] * a[7] -
                       a[0] * a[5] * a[7] -
                       a[2] * a[4] * a[6] -
                       a[1] * a[3] * a[8];
            }
            
            IM.Mat3.invert = function(a) {
                // http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche23.html
                
                var d = IM.Mat3.determinant(a);
                if (d == 0.0) {
                    throw 'Matrix is not invertible';
                }
                
                var s = 1.0 / d;
                var res = new Float32Array(9);
                
                res[0] = s * (a[4] * a[8] - a[7] * a[5]);
                res[3] = s * (a[6] * a[5] - a[3] * a[8]);
                res[6] = s * (a[3] * a[7] - a[6] * a[4]);
                
                res[1] = s * (a[7] * a[2] - a[1] * a[8]);
                res[4] = s * (a[0] * a[8] - a[6] * a[2]);
                res[7] = s * (a[6] * a[1] - a[0] * a[7]);
                
                res[2] = s * (a[1] * a[5] - a[4] * a[2]);
                res[5] = s * (a[3] * a[2] - a[0] * a[5]);
                res[8] = s * (a[0] * a[4] - a[3] * a[1]);
                
                return res;
            }
            
            IM.Mat3.toString = function(m) {
                var str = '';
                str += '[' + m[0] + ', ' + m[3] + ', ' + m[6] + ']\n';
                str += '[' + m[1] + ', ' + m[4] + ', ' + m[7] + ']\n';
                str += '[' + m[2] + ', ' + m[5] + ', ' + m[8] + ']\n';
                return str
            }
            
            //
            // Helpers namespace
            //
            IM.Helpers = {};
            
            //
            // XHR GET single
            //
            IM.Helpers.XHRGet = function(url, callback) {
                var request = new XMLHttpRequest();
                request.onload = function(e) {
                    callback(request.responseText);
                }
                request.onerror = function(e) {
                    callback(null);
                }
                request.open('GET', url);
                request.send();
            }
            
            //
            // XHR GET multiple
            //
            IM.Helpers.XHRGetMultiple = function(urls, callback) {
                var remaining = urls.length;
                var result = {};
                for (var i = 0; i < urls.length; i++) {
                    (function(url) {
                        IM.Helpers.XHRGet(url, function(data) {
                            result[url] = data;
                            remaining--;
                            if (remaining == 0) {
                                callback(result);
                            }
                        });
                    })(urls[i]);
                }
            }
            
            //
            // GL namespace
            //
            IM.GL = {};
            
            //
            // GL Program
            //
            IM.GL.Program = function(gl, vertexShaderCode, fragmentShaderCode) {
                this._uniforms = {};
                this._attributes = {};
                this._gl = gl;
                this._vertexShader = this._createShader(vertexShaderCode, gl.VERTEX_SHADER);
                this._fragmentShader = this._createShader(fragmentShaderCode, gl.FRAGMENT_SHADER);
                this._program = gl.createProgram();
                gl.attachShader(this._program, this._vertexShader);
                gl.attachShader(this._program, this._fragmentShader);
                gl.linkProgram(this._program);
                if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
                    throw gl.getProgramInfoLog(this._program);
                }
            }
            
            IM.GL.Program.prototype = {
            
                constructor: IM.GL.Program,
                
                _createShader: function(code, type) {
                    var gl = this._gl;
                    var shader = gl.createShader(type);
                    gl.shaderSource(shader, code);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        throw gl.getShaderInfoLog(shader);
                    }
                    return shader;
                },
                
                _findUniform: function(name) {
                    if (!(name in this._uniforms)) {
                        this._uniforms[name] = this._gl.getUniformLocation(this._program, name);
                        if (!this._uniforms[name]) {
                            throw 'Invalid uniform: ' + name;
                        }
                    }
                    return this._uniforms[name];
                },
                
                _findAttribute: function(name) {
                    if (!(name in this._attributes)) {
                        this._attributes[name] = this._gl.getAttribLocation(this._program, name);
                        if (!this._attributes[name] < 0) {
                            throw 'Invalid attribute: ' + name;
                        }
                    }
                    return this._attributes[name];
                },
                
                inUse: function() {
                    return (this._gl.getParameter(this._gl.CURRENT_PROGRAM) == this._program);
                },
                
                use: function() {
                    if (!this.inUse()) {
                        this._gl.useProgram(this._program);
                    }
                },
                
                getAttributeLocation: function(name) {
                    return this._findAttribute(name);
                },
                
                setUniform1f: function(name, value) {
                    this._gl.uniform1f(this._findUniform(name), value);
                },
                
                setUniform2f: function(name, x, y) {
                    this._gl.uniform2f(this._findUniform(name), x, y);
                },
                
                setUniform1i: function(name, value) {
                    this._gl.uniform1i(this._findUniform(name), value);
                },
                
                setUniformMatrix3fv: function(name, value) {
                    this._gl.uniformMatrix3fv(this._findUniform(name), false, value);
                },
            }
            
            //
            // Make a quad with texture coordinates
            //
            IM.GL.makeQuad = function(x, y, w, h, texW, texH) {
                return [x, y, 0, 0,               // 0-2
                        x, y + h, 0, texH,        // |/
                        x + w, y, texW, 0,        // 1
                        x, y + h, 0, texH,        //   2
                        x + w, y + h, texW, texH, //  /|
                        x + w, y, texW, 0];       // 0-1
            },
            
            //
            // Offscreen renderer
            //
            IM.GL.OffscreenRenderer = function(config, callback) {
                this._setConfig(config);
                
                this._stateStack = [];
                var context = this;
                var vertexShaderUrl = this._config.vertexShaderUrl;
                var fragmentShaderUrl = this._config.fragmentShaderUrl;
                IM.Helpers.XHRGetMultiple([vertexShaderUrl, fragmentShaderUrl], function(data) {
                    context.program = new IM.GL.Program(context._config.gl, data[vertexShaderUrl], data[fragmentShaderUrl]);
                    context._initialized = true;
                    if (callback) {
                        callback();
                    }
                });
            }
            
            IM.GL.OffscreenRenderer.prototype = {
                
                constructor: IM.GL.OffscreenRenderer,
                
                _setConfig: function(config) {
                    this._config = {
                        // Defaults
                    }
                    for (var key in config) {
                        this._config[key] = config[key];
                    }
                    
                    var gl = this._config.gl;
                    
                    if (!gl) {
                        throw '[OffscreenRenderer config] No GL context specified';
                    }
                    
                    if (!this._config.frameBuffer) {
                        this._config.frameBuffer = gl.createFramebuffer();
                    }
                },
                
                renderToTexture: function(targetTexture) {
                    this._pushState();
                    
                    this.program.use();
                    
                    var gl = this._config.gl;
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._config.frameBuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);
                    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
                        console.error('Incomplete framebuffer');
                    }
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    
                    
                    
                    // TODO: Use these functions
                    
                    //this._gl.viewport(0, 0, this._thumbnail.textureInfo.width, this._thumbnail.textureInfo.height);
                    //this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._offscreenFramebuffer);
                    //this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._thumbnailTemp, 0);    
                    //this._programMaskPass1.use();    
                    //this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
                    //this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);
                    //this._programDisplay.use();        
                    //this._offscreenFramebuffer = this._gl.createFramebuffer();
                    //this._gl.clear(this._gl.COLOR_BUFFER_BIT);
                    //this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
                    
                    
                    this._popState();
                },
                
                _pushState: function() {
                    var gl = this._config.gl;
                    this._stateStack.push({
                        viewport: gl.getParameter(gl.VIEWPORT),
                        program: gl.getParameter(gl.CURRENT_PROGRAM),
                        framebuffer: gl.getParameter(gl.FRAMEBUFFER_BINDING),
                        arrayBuffer: gl.getParameter(gl.ARRAY_BUFFER_BINDING),
                        elementArrayBuffer: gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING),
                    });
                },
                
                _popState: function() {
                    var gl = this._config.gl;
                    var state = this._stateStack.pop()
                    gl.viewport(state.viewport[0], state.viewport[1], state.viewport[2], state.viewport[3]);
                    gl.useProgram(state.program);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, state.framebuffer);
                    gl.bindBuffer(gl.ARRAY_BUFFER, state.arrayBuffer);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, state.elementArrayBuffer);
                },
            }
            
            //
            // Viewer
            //
            IM.Viewer = function(config, callback) {
                
                // Create canvas
                this._canvas = document.createElement('canvas');
                
                // Get WebGL context
                var possibleContextNames = ['webgl', 'experimental-webgl'];
                for (var i = 0; i < possibleContextNames.length; i++) {
                    this._gl = this._canvas.getContext(possibleContextNames[i], { antialias: true, alpha: false, depth: false, stencil: false });
                    if (this._gl) { break; }
                }
                if (!this._gl) { throw 'Failed to get WebGL context'; }
                
                // Set config
                this._setConfig(config);
                
                // Add canvas to DOM
                this._config.domContainer.appendChild(this._canvas);
                
                // Basic WebGL configuration
                var gl = this._gl;
                gl.enable(gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.STENCIL_TEST);
                gl.disable(gl.CULL_FACE);
                gl.clearColor(this._config.clearColor[0], this._config.clearColor[1], this._config.clearColor[2], 1);
                
                // Create animator
                this._animator = new IM.Animator();
                
                // Initialize various state
                this._baseMatrix = IM.Mat3.makeIdentity();
                this._resetState();
                
                // Register mouse/touch/pointer events handlers
                this._registerPointerEventHandlers();
                
                // Handle window resize
                var context = this;
                window.addEventListener('resize', function() { context._resize(); });
                this._resize();
                
                // Load shaders and create GL program
                var vertexShaderUrl = this._config.vertexShaderUrl;
                var fragmentShaderUrl = this._config.fragmentShaderUrl;
                IM.Helpers.XHRGetMultiple([vertexShaderUrl, fragmentShaderUrl], function(data) {
                    context._program = new IM.GL.Program(context._gl, data[vertexShaderUrl], data[fragmentShaderUrl]);
                    context._initialized = true;
                    if (callback) {
                        callback();
                    }
                });
            }
            
            IM.Viewer.prototype = {
                
                constructor: IM.Viewer,
                
                _setConfig: function(config) {

                    // Set default config
                    this._config = {
                        tileSize: 1024,
                        vertexShaderUrl: 'viewerVertexShader.glsl',
                        fragmentShaderUrl: 'viewerFragmentShader.glsl',
                        clearColor: [0.1, 0.1, 0.1],
                    }
                    
                    // Override defaults with user supplied values
                    for (var key in config) {
                        this._config[key] = config[key];
                    }
                    
                    //
                    // Sanity checks, etc.
                    // 
                    
                    // Check that we have a DOM container object
                    if (!this._config.domContainer) { 
                        throw '[Viewer configuration] "domContainer" must be specified'; 
                    }
                    
                    // Check and fix tile size
                    var log2 = Math.log(this._config.tileSize) / Math.log(2);
                    var tileSize = Math.pow(2, Math.floor(log2));
                    tileSize = Math.max(128, Math.min(tileSize, this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE)));
                    if (this._config.tileSize != tileSize) {
                        console.warn('[Viewer configuration] Changed "tileSize" from ' + this._config.tileSize + ' to ' + tileSize + ' to improve performance');
                        this._config.tileSize = tileSize;
                    }
                },
                
                _resetState: function() {
                    // Initialize matrices
                    this._transformMatrix = IM.Mat3.makeIdentity();
                    
                    // Initialize transformation state
                    this._currentScale = 1.0;
                    this._currentPosX = 0.0;
                    this._currentPosY = 0.0;
                    this._currentRotation = 0.0;
                    this._intendedRotation = 0.0;
                    
                    // Initialize animated values
                    this._animator.set('Alpha', 0);
                    this._animator.set('Scale', this._currentScale);
                    this._animator.set('ScaleCenterX', 0);
                    this._animator.set('ScaleCenterY', 0);
                    this._animator.set('PosX', this._currentPosX);
                    this._animator.set('PosY', this._currentPosY);
                    this._animator.set('Rotation', this._currentRotation);
                    this._animator.set('RotationCenterX', 0);
                    this._animator.set('RotationCenterY', 0);
                },
                
                _registerPointerEventHandlers: function() {
                    
                    var context = this;
                    
                    // Mouse event helper function
                    var terminateMouseEvent = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                    
                    // Get position relative to DOM target
                    var getPositionFromEvent =  function(e) {
                        var clientX = e.clientX || e.touches[0].clientX;
                        var clientY = e.clientY || e.touches[0].clientY;
                        var x = clientX - context._canvas.offsetLeft;
                        var y = clientY - context._canvas.offsetTop;
                        var ratio = context._getDpiRatio();
                        return new Float32Array([x * ratio, y * ratio]);
                    }
                    
                    var getImagePositionFromEvent = function(e) {
                        var ptScreen = getPositionFromEvent(e);
                        var matrix = context._makeTransformMatrix();
                        var matrixInv = IM.Mat3.invert(matrix);
                        return IM.Mat3.transformPoint(matrixInv, ptScreen[0], ptScreen[1]);
                    }
                    
                    // Handle mouse wheel events
                    this._canvas.addEventListener('wheel', function(e) {
                        var duration = 750;
                        var scale = context._animator.get('Scale');
                        var factor = (e.deltaY < 0) ? 2.0 : 0.5;
                        context._animator.start('Scale', scale * factor, duration);
                        
                        var ptImage = getImagePositionFromEvent(e);                        
                        context._animator.set('ScaleCenterX', ptImage[0]);
                        context._animator.set('ScaleCenterY', ptImage[1]);
                        
                        context._snapIntoView(duration); // Note: Maybe this doesn't belong here
                        context._invalidate();
                        
                        return terminateMouseEvent(e);
                    });
                    
                    var pointerStart = function(e, clientX, clientY) {
                        context._dragStart = getPositionFromEvent(e);
                        context._dragStartPos = [
                            context._animator.get('PosX'),
                            context._animator.get('PosY')];
                        return terminateMouseEvent(e);
                    }
                    
                    var pointerEnd = function(e) {
                        context._dragStart = undefined;
                        context._snapIntoView(500);
                        return terminateMouseEvent(e);
                    }
                    
                    var pointerMove = function(e, clientX, clientY) {
                        if (context._dragStart) {
                            var pt = getPositionFromEvent(e);
                            var dx = pt[0] - context._dragStart[0];
                            var dy = pt[1] - context._dragStart[1];
                            context._animator.set('PosX', context._dragStartPos[0] + dx);
                            context._animator.set('PosY', context._dragStartPos[1] + dy);
                            context._invalidate();
                            return terminateMouseEvent(e);
                        }
                    }
                    
                    var initGestureScale;
                    var initGestureRotation;
                    this._canvas.addEventListener('gesturestart', function(e) {
                        var ptImage = getImagePositionFromEvent(e);
                        context._animator.set('ScaleCenterX', ptImage[0]);
                        context._animator.set('ScaleCenterY', ptImage[1]);
                        context._animator.set('RotationCenterX', ptImage[0]);
                        context._animator.set('RotationCenterY', ptImage[1]);
                        initGestureScale = context._animator.get('Scale');
                        initGestureRotation = context._animator.get('Rotation');
                    });
                    
                    this._canvas.addEventListener('gesturechange', function(e) {
                        var deg2rad = function(deg) { return deg / 180 * Math.PI; }
                        context._animator.set('Rotation', initGestureRotation - deg2rad(e.rotation));
                        context._animator.set('Scale', initGestureScale * e.scale);
                        context._invalidate();
                    });
                    
                    this._canvas.addEventListener('touchstart', function(e) {
                        return pointerStart(e, e.touches[0].clientX, e.touches[0].clientY);
                    });
                    

                    this._canvas.addEventListener('mousedown', function(e) {
                        return pointerStart(e, e.clientX, e.clientY);
                    });
                    
                    this._canvas.addEventListener('touchend', function(e) {
                        return pointerEnd(e);
                    });
                                      
                    window.addEventListener('mouseup', function(e) {
                        return pointerEnd(e);
                    });
                    
                    window.addEventListener('mousemove', function(e) {
                       return pointerMove(e, e.clientX, e.clientY)
                    });
                    
                    window.addEventListener('touchmove', function(e) {
                       return pointerMove(e, e.touches[0].clientX, e.touches[0].clientY);
                    });
                },
                
                setImageByUrl: function(url, callback) {
                    var im = new Image();
                    var context = this;
                    im.onload = function() {
                        context.setImage(im);
                        if (callback) {
                            callback();
                        }
                    };
                    im.src = url;
                },
                
                setImage: function(im) {
                    
                    var gl = this._gl;
                    
                    // Delete old textures if they exist
                    if (this._tiles) {
                        for (var i = 0; i < this._tiles.length; i++) {
                            gl.deleteTexture(this._tiles[i]);
                        }
                    }
                    
                    // Create tiles and geometry
                    this._tiles = [];
                    this._imageSize = [im.width, im.height];
                    var buffer = [];
                    var tileSize = this._config.tileSize;
                    var roundPot = function(x) { return Math.pow(2.0, Math.ceil(Math.log(x) / Math.log(2.0))); }
                    for (var y = 0; y < im.height; y += tileSize) {
                    
                        var height = Math.min(tileSize, im.height - y);
                        var heightPot = roundPot(height);
                    
                        for (var x = 0; x < im.width; x += tileSize) {
                        
                            var width = Math.min(tileSize, im.width - x);
                            var widthPot = roundPot(width);
                            
                            // Create tile texture
                            var tileIm = this._cropImage(im, x, y, widthPot, heightPot);
                            var tileTex = this._createTexture(tileIm);
                            this._tiles.push(tileTex);
                            
                            // Create geometry quad and append it to vertex/UV array
                            var quad = IM.GL.makeQuad(x, y, width, height, width / widthPot, height / heightPot);
                            Array.prototype.push.apply(buffer, quad);
                        }
                    }
                    
                    // Delete old buffer if it already exists
                    if (this._buffer) {
                        gl.deleteBuffer(this._buffer);
                    }
                    
                    // Create and initialize new buffer
                    this._buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer), gl.STATIC_DRAW);
                    
                    // Use program
                    this._program.use();
                    
                    // Enable and configure buffer
                    var bufferLocation = this._program.getAttributeLocation('PositionTexCoord');
                    gl.enableVertexAttribArray(bufferLocation); // Note: This operates on the currently bound ARRAY_BUFFER
                    gl.vertexAttribPointer(bufferLocation, 4, gl.FLOAT, false, 0, 0);

                    // Reset state
                    this._resetState();
                    
                    // Zoom to fit and fade in
                    this.zoomToFit(0);
                    this._animator.start('Alpha', 1, 800);
                    this._invalidate();
                },
                
                zoomToFit: function(animDuration) {

                    // Scale
                    var matrix = this._makeTransformMatrix({
                        rotation: this._animator.getDestination('Rotation') });
                    var rect = this._getImageRect(matrix);
                    var sx = this._canvas.width / rect.bounds.width;
                    var sy = this._canvas.height / rect.bounds.height;
                    var newScale = this._animator.get('Scale') * Math.min(sx, sy);
                    this._animator.start('Scale', newScale, animDuration);

                    // Position
                    var matrix = this._makeTransformMatrix({ 
                        rotation: this._animator.getDestination('Rotation'),
                        scale: this._animator.getDestination('Scale') });
                    var rect = this._getImageRect(matrix);
                    var x0 = (this._canvas.width - rect.bounds.width) * 0.5;
                    var y0 = (this._canvas.height - rect.bounds.height) * 0.5;
                    var newPosX = this._animator.get('PosX') + (x0 - rect.bounds.x0);
                    var newPosY = this._animator.get('PosY') + (y0 - rect.bounds.y0);
                    this._animator.start('PosX', newPosX, animDuration);
                    this._animator.start('PosY', newPosY, animDuration);
                    
                    this._invalidate();
                },
                
                zoom: function(scale, animDuration) {
                    
                    var matrix = this._makeTransformMatrix({ rotation: this._animator.getDestination('Rotation') });
                    var matrixInv = IM.Mat3.invert(matrix);
                
                    var pt0 = IM.Mat3.transformPoint(matrixInv, 0, 0);
                    var pt1 = IM.Mat3.transformPoint(matrixInv, this._canvas.width, this._canvas.height);
                    
                    var cx = pt0[0] + (pt1[0] - pt0[0]) * 0.5;
                    var cy = pt0[1] + (pt1[1] - pt0[1]) * 0.5;
                    
                    this._animator.set('ScaleCenterX', cx);
                    this._animator.set('ScaleCenterY', cy);
                    
                    this._animator.start('Scale', scale, animDuration);
                    this._snapIntoView(animDuration); // Note: Maybe this doesn't belong here
                    this._invalidate();
                },
                
                _cropImage: function(im, x, y, width, height) {
                    var cvs = document.createElement('canvas');
                    cvs.width = width;
                    cvs.height = height;
                    var ctx = cvs.getContext('2d');
                    var maxWidth = im.width - x;
                    var maxHeight = im.height - y;
                    var w = Math.min(maxWidth, width);
                    var h = Math.min(maxHeight, height);
                    ctx.drawImage(im, x, y, w, h, 0, 0, w, h);
                    return cvs;
                },
                
                _createTexture: function(im) {
                    var gl = this._gl;
                    var tex = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, tex);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, im);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    return tex;
                },
                
                _getDpiRatio: function() {
                    var gl = this._gl;
                    var devicePixelRatio = window.devicePixelRatio || 1;
                    var backingStorePixelRatio = gl.webkitBackingStorePixelRatio ||
                                                 gl.mozBackingStorePixelRatio ||
                                                 gl.msBackingStorePixelRatio ||
                                                 gl.oBackingStorePixelRatio ||
                                                 gl.backingStorePixelRatio || 1;
                    return devicePixelRatio / backingStorePixelRatio;
                },
                
                _resize: function() {
                    var style = window.getComputedStyle(this._config.domContainer);
                    var width = Math.ceil(parseFloat(style.width));
                    var height = Math.ceil(parseFloat(style.height));
                    
                    var ratio = this._getDpiRatio();
                    var pixelWidth = Math.round(width * ratio);
                    var pixelHeight = Math.round(height * ratio);
                    
                    this._canvas.style.width = width + 'px';
                    this._canvas.style.height = height + 'px';
                    this._canvas.width = pixelWidth;
                    this._canvas.height = pixelHeight;
                    this._gl.viewport(0, 0, pixelWidth, pixelHeight);
                    this._gl.scissor(0, 0, pixelWidth, pixelHeight);
                    
                    // Create 'base matrix' (including aspect-ratio, topleft-origin, pixel-scale)
                    var m0 = IM.Mat3.makeScale(1, -1);
                    var m1 = IM.Mat3.makeTranslation(-1, -1);
                    var m2 = IM.Mat3.makeScale(2 / pixelWidth, 2 / pixelHeight);
                    this._baseMatrix = IM.Mat3.multiply(m0, m1, m2);
                    
                    this._invalidate();
                },
                
                _invalidate: function() {
                    if (!this._renderPending) {
                        this._renderPending = true;
                        var context = this;
                        requestAnimationFrame(function() {
                            var finished = context._render();
                            context._renderPending = false;
                            if (!finished) {
                                context._invalidate();
                            }
                        });
                    }
                },
                
                _snapIntoView: function(duration) {
                
                    // Compute image rectangle
                    var matrix = this._makeTransformMatrix({ 
                        scale: this._animator.getDestination('Scale'), 
                        rotation: this._animator.getDestination('Rotation')});
                    var rect = this._getImageRect(matrix);
                    
                    // Get canvas dimension
                    var width = this._canvas.width;
                    var height = this._canvas.height;
                    
                    // Get current position
                    var oldX = this._animator.get('PosX');
                    var oldY = this._animator.get('PosY');
                    
                    // Variables
                    var newX, newY, delta = 1;
                    
                    // Does the image fit within the canvas?
                    var fitX = (rect.bounds.width - delta <= width);
                    var fitY = (rect.bounds.height - delta <= height);
                    
                    // Handle x axis snapping
                    if (fitX) {
                        if (rect.bounds.x0 < 0)           { newX = oldX + Math.abs(rect.bounds.x0);  }
                        else if (rect.bounds.x1 > width)  { newX = oldX - (rect.bounds.x1 - width);  }
                    } else {
                        if (rect.bounds.x1 < width)       { newX = oldX + (width - rect.bounds.x1);  }
                        else if (rect.bounds.x0 > 0)      { newX = oldX - rect.bounds.x0;            }
                    }
                    
                    // Handle y axis snapping
                    if (fitY) {
                        if (rect.bounds.y0 < 0)           { newY = oldY + Math.abs(rect.bounds.y0);  }
                        else if (rect.bounds.y1 > height) { newY = oldY - (rect.bounds.y1 - height); }
                    } else {
                        if (rect.bounds.y1 < height)      { newY = oldY + (height- rect.bounds.y1);  }
                        else if (rect.bounds.y0 > 0)      { newY = oldY - rect.bounds.y0;            }
                    }
                    
                    // If snapping is needed, do the appropriate animation
                    if (newX !== undefined) {
                        this._animator.start('PosX', newX, duration);
                        this._invalidate();
                    }
                    
                    if (newY !== undefined) {
                        this._animator.start('PosY', newY, duration);
                        this._invalidate();
                    }
                },
                
                rotate: function(duration) {
                    
                    this._animator.set('RotationCenterX', this._imageSize[0] * 0.5);
                    this._animator.set('RotationCenterY', this._imageSize[1] * 0.5);
                    
                    this._intendedRotation -= Math.PI * 0.5;
                    
                    this._animator.start('Rotation', this._intendedRotation, duration);
                    this._snapIntoView(duration)
                    
                    this._invalidate();
                },
                
                _getImageRect: function(matrix) {
                    
                    // Find transformed image coordinates (aka. the current position of the image)
                    var tl = IM.Mat3.transformPoint(matrix, 0, 0);
                    var tr = IM.Mat3.transformPoint(matrix, this._imageSize[0], 0);
                    var br = IM.Mat3.transformPoint(matrix, this._imageSize[0], this._imageSize[1]);
                    var bl = IM.Mat3.transformPoint(matrix, 0, this._imageSize[1]);
                    var center = IM.Mat3.transformPoint(matrix, this._imageSize[0] * 0.5, this._imageSize[1] * 0.5);
                  
                    var distance = function(a, b) {
                        var dx = a[0] - b[0];
                        var dy = a[1] - b[1];
                        return Math.sqrt(dx * dx + dy * dy);
                    }
                    
                    var bounds = {
                        x0: Math.min(tl[0], Math.min(tr[0], Math.min(bl[0], br[0]))),
                        x1: Math.max(tl[0], Math.max(tr[0], Math.max(bl[0], br[0]))),
                        y0: Math.min(tl[1], Math.min(tr[1], Math.min(bl[1], br[1]))),
                        y1: Math.max(tl[1], Math.max(tr[1], Math.max(bl[1], br[1])))
                    }
                    
                    bounds.width = bounds.x1 - bounds.x0;
                    bounds.height = bounds.y1 - bounds.y0;
                    
                    var rotation = Math.PI * 2.0 - Math.atan2(tr[1] - tl[1], tr[0] - tl[0]);
                    
                    return {
                        topLeft: tl, 
                        topRight: tr,
                        bottomLeft: bl,
                        bottomRight: br,
                        width: distance(tl, tr), 
                        height: distance(tr, br), 
                        rotation: rotation, 
                        center: center, 
                        bounds: bounds};
                },
                
                _makeTransformMatrix: function(args) {

                    // Get target values
                    var scale = args && args.scale ? args.scale : this._animator.get('Scale');
                    var posX = args && args.posX ? args.posX : this._animator.get('PosX');
                    var posY = args && args.posY ? args.posY : this._animator.get('PosY');
                    var rotation = args && args.rotation ? args.rotation : this._animator.get('Rotation');
                    var updateState = args && args.updateState ? args.updateState : false;
                    
                    // Create scale delta-matrix
                    var deltaScale = scale / this._currentScale;
                    var deltaScaleMatrix = IM.Mat3.makeScale(deltaScale, deltaScale);
                    
                    // Create scale-center matrices
                    var scaleCenterX = this._animator.get('ScaleCenterX');
                    var scaleCenterY = this._animator.get('ScaleCenterY');
                    var scaleCenterMatrix = IM.Mat3.makeTranslation(scaleCenterX, scaleCenterY);
                    var scaleCenterInvMatrix = IM.Mat3.invert(scaleCenterMatrix);
                    
                    // Create position delta-matrix
                    var deltaPosX = (posX - this._currentPosX); // Note: Rounding these coordinates fixes interpolation artifacts during animations, but it also introduces accumulating errors in the transformation matrix
                    var deltaPosY = (posY - this._currentPosY);
                    var deltaPosMatrix = IM.Mat3.makeTranslation(deltaPosX, deltaPosY);
                    
                    // Create rotation delta-matrix
                    var deltaRotation = rotation - this._currentRotation;
                    var deltaRotationMatrix = IM.Mat3.makeRotation(deltaRotation);
                    
                    // Create rotation-center matrices
                    var rotationCenterX = this._animator.get('RotationCenterX');
                    var rotationCenterY = this._animator.get('RotationCenterY');
                    var rotationCenterMatrix = IM.Mat3.makeTranslation(rotationCenterX, rotationCenterY);
                    var rotationCenterInvMatrix = IM.Mat3.invert(rotationCenterMatrix);
                    
                    // Update state, if requested
                    if (updateState) {
                        this._currentPosX = posX;
                        this._currentPosY = posY;
                        this._currentScale = scale;
                        this._currentRotation = rotation;
                    }
                    
                    // Compute and return transformation matrix
                    return IM.Mat3.multiply(
                        deltaPosMatrix,
                        this._transformMatrix,
                        scaleCenterMatrix, 
                        deltaScaleMatrix, 
                        scaleCenterInvMatrix,
                        rotationCenterMatrix, 
                        deltaRotationMatrix, 
                        rotationCenterInvMatrix);
                },
                
                _render: function() {
                    var gl = this._gl;
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    if (this._initialized && this._tiles) {
                        
                        this._transformMatrix = this._makeTransformMatrix({ updateState: true });
                        var matrix = IM.Mat3.multiply(this._baseMatrix, this._transformMatrix);
                        
                        this._program.setUniformMatrix3fv('Matrix', matrix);
                        this._program.setUniform1f('Alpha', this._animator.get('Alpha'));
                        this._program.setUniform1i('Texture', 0);
                        
                        gl.activeTexture(gl.TEXTURE0);
                        
                        for (var i = 0; i < this._tiles.length; i++) {
                        
                            var tile = this._tiles[i];
                            if (this._config.onBeforeRenderTile) {
                                tile = this._config.onBeforeRenderTile(tile)
                            }
                        
                            gl.bindTexture(gl.TEXTURE_2D, tile);
                            gl.drawArrays(gl.TRIANGLES, i * 6, 6);
                        }
                    }
                    return this._animator.finished();
                },
            }
            
            
            
            
            
            
            //
            // For testing purposes
            //
            var _viewer;
            var _swap = 0;
            var _swapping = false;
            function init() {
                
                var viewerConfig = {
                    domContainer: document.getElementById('container'),
                    tileSize: 1024,
                };
                _viewer = new IM.Viewer(viewerConfig, function() {
                    _viewer.setImageByUrl('image.jpg', function() {
                        console.log('ready');
                    });
                });
                
            }
            function zoomToFit() { _viewer.zoomToFit(750); }
            function zoom100() { _viewer.zoom(1.0, 750); }
            function rotate() { _viewer.rotate(500); }
            function swapImage() { 
                if (!_swapping) {
                    _swapping = true;
                    _viewer.setImageByUrl((_swap % 2 == 0) ? 'image.png' : 'image.jpg', function() {
                        _swap += 1;
                        _swapping = false;
                    });
                }
            }
        
        </script>
    </head>
    
    <body onload='init()'>
        <div id='container'></div>
        <div id='controls'>
            <div class='control' onclick='zoomToFit()'>Zoom/fit</div>
            <div class='control' onclick='zoom100()'>Zoom/100%</div>
            <div class='control' onclick='rotate()'>Rotate</div>
            <div class='control' onclick='swapImage()'>Swap image</div>
            
        </div>
    </body>

</html>