<!DOCTYPE html>

<html>

    <head>
        <meta charset='utf-8'>
        <title>Tiled Viewer Test</title>
        <style>
            html {
                width: 100%;
                height: 100%;
                margin: 0px;
                padding: 0px;
            }
            body {
                width: 100%;
                height: 100%;
                margin: 0px;
                padding: 0px;
                display: flex;
                flex-flow: column nowrap;
                background: #202020;
                justify-content: center;
                align-items: center;
            }
            #container {
                width: 90%;
                height: 86%;
                border: 1px solid white;
                overflow: hidden;
            }
        </style>
        <script>
            
            'use strict';
        
            //
            // Top level namespace
            //
            var IM = {};
            
            //
            // Animator
            //
            IM.Animator = function() {
                this._animations = {};
            }
            
            IM.Animator.prototype = {
                
                constructor: IM.Animator,
                
                start: function(name, to, duration) {
                    var animation = {
                        from: this.get(name),
                        to: to,
                        duration: duration,
                        t0: Date.now(),
                    };
                    this._animations[name] = animation;
                },
                
                set: function(name, value) {
                    this.start(name, value, 0);
                },
                
                finished: function() {
                    for (var key in this._animations) {
                        if (!this._animations[key].finished) {
                            return false;
                        }
                    }
                    return true;
                },
                
                getDestination: function(name) {
                    var animation = this._animations[name];
                    if (!animation) {
                        return 0;
                    }
                    return animation.to;
                },
                
                get: function(name) {
                    var animation = this._animations[name];
                    if (!animation) {
                        return 0;
                    }
                    var dt = Date.now() - animation.t0;
                    var t = Math.min(1.0, dt / animation.duration);
                    if (t < 1.0) {
                        t = t - 1.0;
                        t = -(t * t * t * t - 1.0);
                        return animation.from + t * (animation.to - animation.from);
                    } else {
                        animation.finished = true;
                        return animation.to;
                    }
                },
            }
            
            //
            // 3x3 Matrix namespace
            //
            IM.Mat3 = {};
            
            IM.Mat3.makeIdentity = function() {
                return new Float32Array([
                    1, 0, 0, 
                    0, 1, 0, 
                    0, 0, 1]);
            }
            
            IM.Mat3.makeTranslation = function(tx, ty) {
                return new Float32Array([
                    1.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    tx,  ty,  1.0]);
            }
            
            IM.Mat3.makeScale = function(sx, sy) {
                return new Float32Array([
                    sx,  0.0, 0.0,
                    0.0, sy,  0.0,
                    0.0, 0.0, 1.0]);
            }
            
            IM.Mat3.makeRotation = function(rad) {
                var sin = Math.sin(rad);
                var cos = Math.cos(rad);
                return new Float32Array([
                    cos, -sin, 0.0,
                    sin,  cos, 0.0,
                    0.0,  0.0, 1.0]);
            }
            
            IM.Mat3.multiplyTwo = function(a, b) {
                var res = new Float32Array(9);
                    
                res[0] = a[0] * b[0] + a[3] * b[1] + a[6] * b[2];
                res[3] = a[0] * b[3] + a[3] * b[4] + a[6] * b[5];
                res[6] = a[0] * b[6] + a[3] * b[7] + a[6] * b[8];
                
                res[1] = a[1] * b[0] + a[4] * b[1] + a[7] * b[2];
                res[4] = a[1] * b[3] + a[4] * b[4] + a[7] * b[5];
                res[7] = a[1] * b[6] + a[4] * b[7] + a[7] * b[8];
                
                res[2] = a[2] * b[0] + a[5] * b[1] + a[8] * b[2];
                res[5] = a[2] * b[3] + a[5] * b[4] + a[8] * b[5];
                res[8] = a[2] * b[6] + a[5] * b[7] + a[8] * b[8];
                    
                return res;
            }
            
            IM.Mat3.transformPoint = function(m, x, y) {
                var res = new Float32Array(2);
                
                res[0] = m[0] * x + m[3] * y + m[6];
                res[1] = m[1] * x + m[4] * y + m[7];
                
                return res;
            }
            
            IM.Mat3.multiply = function() {
                switch (arguments.length) {
                    case 0: return null;
                    case 1: return arguments[1];
                    default:
                        var res = IM.Mat3.multiplyTwo(arguments[0], arguments[1]);
                        for (var i = 2; i < arguments.length; i++) {
                            res = IM.Mat3.multiplyTwo(res, arguments[i]);
                        }
                        return res;
                }
            }
            
            IM.Mat3.transpose = function(a) {
                var res = new Float32Array(9);
                    
                res[0] = a[0];
                res[1] = a[3];
                res[2] = a[6];
                
                res[3] = a[1];
                res[4] = a[4];
                res[5] = a[7];
                
                res[6] = a[2];
                res[7] = a[5];
                res[8] = a[8];
                
                return res;
            }
            
            IM.Mat3.determinant = function(a) {
                // http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche23.html
                
                return a[0] * a[4] * a[8] +
                       a[1] * a[5] * a[6] +
                       a[2] * a[3] * a[7] -
                       a[0] * a[5] * a[7] -
                       a[2] * a[4] * a[6] -
                       a[1] * a[3] * a[8];
            }
            
            IM.Mat3.invert = function(a) {
                // http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche23.html
                
                var d = IM.Mat3.determinant(a);
                if (d == 0.0) {
                    throw 'Matrix is not invertible';
                }
                
                var s = 1.0 / d;
                var res = new Float32Array(9);
                
                res[0] = s * (a[4] * a[8] - a[7] * a[5]);
                res[3] = s * (a[6] * a[5] - a[3] * a[8]);
                res[6] = s * (a[3] * a[7] - a[6] * a[4]);
                
                res[1] = s * (a[7] * a[2] - a[1] * a[8]);
                res[4] = s * (a[0] * a[8] - a[6] * a[2]);
                res[7] = s * (a[6] * a[1] - a[0] * a[7]);
                
                res[2] = s * (a[1] * a[5] - a[4] * a[2]);
                res[5] = s * (a[3] * a[2] - a[0] * a[5]);
                res[8] = s * (a[0] * a[4] - a[3] * a[1]);
                
                return res;
            }
            
            IM.Mat3.toString = function(m) {
                var str = '';
                str += '[' + m[0] + ', ' + m[3] + ', ' + m[6] + ']\n';
                str += '[' + m[1] + ', ' + m[4] + ', ' + m[7] + ']\n';
                str += '[' + m[2] + ', ' + m[5] + ', ' + m[8] + ']\n';
                return str
            }
            
            //
            // Helpers namespace
            //
            IM.Helpers = {};
            
            //
            // XHR GET single
            //
            IM.Helpers.XHRGet = function(url, callback) {
                var request = new XMLHttpRequest();
                request.onload = function(e) {
                    callback(request.responseText);
                }
                request.onerror = function(e) {
                    callback(null);
                }
                request.open('GET', url);
                request.send();
            }
            
            //
            // XHR GET multiple
            //
            IM.Helpers.XHRGetMultiple = function(urls, callback) {
                var remaining = urls.length;
                var result = {};
                for (var i = 0; i < urls.length; i++) {
                    (function(url) {
                        IM.Helpers.XHRGet(url, function(data) {
                            result[url] = data;
                            remaining--;
                            if (remaining == 0) {
                                callback(result);
                            }
                        });
                    })(urls[i]);
                }
            }
            
            //
            // GL namespace
            //
            IM.GL = {};
            
            //
            // GL Program
            //
            IM.GL.Program = function(gl, vertexShaderCode, fragmentShaderCode) {
                this._uniforms = {};
                this._attributes = {};
                this._gl = gl;
                this._vertexShader = this._createShader(vertexShaderCode, gl.VERTEX_SHADER);
                this._fragmentShader = this._createShader(fragmentShaderCode, gl.FRAGMENT_SHADER);
                this._program = gl.createProgram();
                gl.attachShader(this._program, this._vertexShader);
                gl.attachShader(this._program, this._fragmentShader);
                gl.linkProgram(this._program);
                if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
                    throw gl.getProgramInfoLog(this._program);
                }
            }
            
            IM.GL.Program.prototype = {
            
                constructor: IM.GL.Program,
                
                _createShader: function(code, type) {
                    var gl = this._gl;
                    var shader = gl.createShader(type);
                    gl.shaderSource(shader, code);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        throw gl.getShaderInfoLog(shader);
                    }
                    return shader;
                },
                
                _findUniform: function(name) {
                    if (!(name in this._uniforms)) {
                        this._uniforms[name] = this._gl.getUniformLocation(this._program, name);
                        if (!this._uniforms[name]) {
                            throw 'Invalid uniform: ' + name;
                        }
                    }
                    return this._uniforms[name];
                },
                
                _findAttribute: function(name) {
                    if (!(name in this._attributes)) {
                        this._attributes[name] = this._gl.getAttribLocation(this._program, name);
                        if (!this._attributes[name] < 0) {
                            throw 'Invalid attribute: ' + name;
                        }
                    }
                    return this._attributes[name];
                },
                
                use: function() {
                    this._gl.useProgram(this._program);
                },
                
                getAttributeLocation: function(name) {
                    return this._findAttribute(name);
                },
                
                setUniform1f: function(name, value) {
                    this._gl.uniform1f(this._findUniform(name), value);
                },
                
                setUniform1i: function(name, value) {
                    this._gl.uniform1i(this._findUniform(name), value);
                },
                
                setUniformMatrix3fv: function(name, value) {
                    this._gl.uniformMatrix3fv(this._findUniform(name), false, value);
                },
            }
            
            //
            // Viewer
            //
            IM.Viewer = function(domContainer) {
                this._domContainer = domContainer;
                this._canvas = document.createElement('canvas');
                
                var possibleContextNames = ['webgl', 'experimental-webgl'];
                for (var i = 0; i < possibleContextNames.length; i++) {
                    this._gl = this._canvas.getContext(possibleContextNames[i], { antialias: true, alpha: false, depth: false, stencil: false });
                    if (this._gl) {
                        break;
                    }
                }
                if (!this._gl) {
                    throw 'Failed to get WebGL context';
                }
                
                this._domContainer.appendChild(this._canvas);
                this._animator = new IM.Animator();
                this._baseMatrix = IM.Mat3.makeIdentity();
                this._scaleMatrix = IM.Mat3.makeIdentity();
                this._posMatrix = IM.Mat3.makeIdentity();
                this._rotationMatrix = IM.Mat3.makeIdentity();
                this._resize();
                
                var gl = this._gl;
                gl.enable(this._gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
                gl.disable(this._gl.DEPTH_TEST);
                gl.disable(this._gl.CULL_FACE);
                gl.clearColor(0.1, 0.1, 0.1, 1);
                
                var context = this;
                window.addEventListener('resize', function() { context._resize(); });
            }
            
            IM.Viewer.prototype = {
                
                constructor: IM.Viewer,
                
                initialize: function(callback) {
                    var vertexShaderName = 'viewerVertexShader.glsl';
                    var fragmentShaderName = 'viewerFragmentShader.glsl';
                    var context = this;
                    IM.Helpers.XHRGetMultiple([vertexShaderName, fragmentShaderName], function(data) {
                        context._program = new IM.GL.Program(context._gl, data[vertexShaderName], data[fragmentShaderName]);
                        context._initializeEvents();
                        context._initialized = true;
                        if (callback) {
                            callback();
                        }
                    });
                },
                
                _getPositionFromEvent: function(e) {
                    var x = e.clientX - e.target.offsetLeft;
                    var y = e.clientY - e.target.offsetTop;
                    return new Float32Array([x, y]);
                },
                
                _initializeEvents: function() {
                
                    // Reset animation values + state
                    this._animator.set('Alpha', 0);
                
                    this._currentScale = 1.0;
                    this._animator.set('Scale', this._currentScale);
                    
                    this._currentPosX = 0.0;
                    this._animator.set('PosX', this._currentPosX);
                    
                    this._currentPosY = 0.0;
                    this._animator.set('PosY', this._currentPosY);
                    
                    this._currentRotation = 0.0;
                    this._animator.set('Rotation', this._currentRotation);
                    
                    var context = this;
                    
                    // Mouse event helper function
                    var terminateMouseEvent = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                    
                    // Handle mouse wheel events
                    this._canvas.addEventListener('wheel', function(e) {
                        var scale = context._animator.get('Scale');
                        var factor = (e.deltaY < 0) ? 2.0 : 0.5;
                        context._animator.start('Scale', scale * factor, 750);
                        
                        var ptScreen = context._getPositionFromEvent(e);
                        
                        context._updateMatrices();
                        var matrix = IM.Mat3.multiply(context._posMatrix, context._scaleMatrix, context._rotationMatrix);
                        var matrixInv = IM.Mat3.invert(matrix);
                    
                        var ptImage = IM.Mat3.transformPoint(matrixInv, ptScreen[0], ptScreen[1]);
                        
                        context._animator.set('ScaleCenterX', ptImage[0]);
                        context._animator.set('ScaleCenterY', ptImage[1]);
                        
                        context._invalidate();
                        return terminateMouseEvent(e);
                    });
                    
                    // Handle mouse down
                    this._canvas.addEventListener('mousedown', function(e) {
                        context._dragStart = [e.clientX, e.clientY];
                        context._dragStartPos = [
                            context._animator.get('PosX'),
                            context._animator.get('PosY')];
                        return terminateMouseEvent(e);
                    });
                    
                    // Handle mouse up
                    window.addEventListener('mouseup', function(e) {
                        context._dragStart = undefined;
                        context._snapBack();
                        return terminateMouseEvent(e);
                    });
                    
                    // Handle mouse move
                    window.addEventListener('mousemove', function(e) {
                        if (context._dragStart) {
                            var pt = [e.clientX, e.clientY];
                            var dx = pt[0] - context._dragStart[0];
                            var dy = pt[1] - context._dragStart[1];
                            context._animator.set('PosX', context._dragStartPos[0] + dx);
                            context._animator.set('PosY', context._dragStartPos[1] + dy);
                            context._invalidate();
                            return terminateMouseEvent(e);
                        }
                    });
                },
                
                setImage: function(url, callback) {
                    var im = new Image();
                    var context = this;
                    im.onload = function() {
                        context._setImage(im);
                        if (callback) {
                            callback();
                        }
                    };
                    im.src = url;
                },
                
                _createQuad: function(x, y, w, h, texW, texH) {
                    return [x,     y,     0,    0,     // 0-2
                            x,     y + h, 0,    texH,  // |/
                            x + w, y,     texW, 0,     // 1
                            x,     y + h, 0,    texH,  //   2
                            x + w, y + h, texW, texH,  //  /|
                            x + w, y,     texW, 0];    // 0-1
                },
                
                _setImage: function(im) {
                    
                    // Create tiles and geometry
                    this._imageSize = [im.width, im.height];
                    this._tiles = [];
                    var buffer = [];
                    var tileSize = 1024;
                    var roundPot = function(x) { return Math.pow(2.0, Math.ceil(Math.log(x) / Math.log(2.0))); }
                    for (var y = 0; y < im.height; y += tileSize) {
                    
                        var height = Math.min(tileSize, im.height - y);
                        var heightPot = roundPot(height);
                    
                        for (var x = 0; x < im.width; x += tileSize) {
                        
                            var width = Math.min(tileSize, im.width - x);
                            var widthPot = roundPot(width);
                            
                            // Create tile texture
                            var tileIm = this._cropImage(im, x, y, widthPot, heightPot);
                            var tileTex = this._createTexture(tileIm);
                            this._tiles.push(tileTex);
                            
                            // Create geometry quad and append it to vertex/UV array
                            var quad = this._createQuad(x, y, width, height, width / widthPot, height / heightPot);
                            Array.prototype.push.apply(buffer, quad);
                        }
                    }
                    
                    this._program.use();
                    var gl = this._gl;
                    
                    // Create buffer
                    this._buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer), gl.STATIC_DRAW);
                    
                    // Enable and configure buffer
                    var bufferLocation = this._program.getAttributeLocation('PositionTexCoord');
                    gl.enableVertexAttribArray(bufferLocation);
                    gl.vertexAttribPointer(bufferLocation, 4, gl.FLOAT, false, 0, 0);
                    
                    // Zoom to fit and fade in
                    this.zoomToFit(0);
                    this._animator.start('Alpha', 1, 800);
                    this._invalidate();
                },
                
                zoomToFit: function(animDuration) {

                    this._resetMatrices();

                    // Zoom to fit
                    var sx = this._canvas.width / this._imageSize[0];
                    var sy = this._canvas.height / this._imageSize[1];
                    var s = Math.min(sx, sy);
                    this._animator.start('Scale', s, animDuration);
                    
                    // Center
                    var x0 = (this._canvas.width - this._imageSize[0] * s) * 0.5;
                    var y0 = (this._canvas.height - this._imageSize[1] * s) * 0.5;
                    this._animator.start('PosX', x0, animDuration);
                    this._animator.start('PosY', y0, animDuration);
                    
                    this._invalidate();
                },
                
                _cropImage: function(im, x, y, width, height) {
                    var cvs = document.createElement('canvas');
                    cvs.width = width;
                    cvs.height = height;
                    var ctx = cvs.getContext('2d');
                    ctx.drawImage(im, x, y, width, height, 0, 0, width, height);
                    return cvs;
                },
                
                _createTexture: function(im) {
                    var gl = this._gl;
                    var tex = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, tex);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, im);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    return tex;
                },
                
                _resize: function() {
                    var style = window.getComputedStyle(this._domContainer);
                    var width = Math.ceil(parseFloat(style.width));
                    var height = Math.ceil(parseFloat(style.height));
                    this._canvas.width = width;
                    this._canvas.height = height;
                    this._gl.viewport(0, 0, width, height);
                    this._gl.scissor(0, 0, width, height);
                    
                    // Create 'base matrix' (including aspect-ratio, topleft-origin, pixel-scale)
                    var m0 = IM.Mat3.makeScale(1, -1);
                    var m1 = IM.Mat3.makeTranslation(-1, -1);
                    var m2 = IM.Mat3.makeScale(2 / width, 2 / height);
                    this._baseMatrix = IM.Mat3.multiply(m0, m1, m2);
                    
                    this._invalidate();
                },
                
                _invalidate: function() {
                    if (!this._renderPending) {
                        this._renderPending = true;
                        var context = this;
                        requestAnimationFrame(function() {
                            var finished = context._render();
                            context._renderPending = false;
                            if (!finished) {
                                context._invalidate();
                            }
                        });
                    }
                },
                
                _snapBack: function() {
                
                    // Get image rectangle
                    this._resetMatrices();
                    var rect = this._getImageRect();
                    
                    // Get canvas dimension
                    var width = this._canvas.width;
                    var height = this._canvas.height;
                    
                    // Variables
                    var delta = 1;
                    var newX, newY;
                    
                    // Handle x axis snapping
                    if (rect.x0 < 0 && rect.width - delta <= width) {
                        newX = 0;
                    }
                    else if (rect.x1 > width && rect.width - delta <= width) {
                        newX = width - rect.width;
                    }
                    else if (rect.x1 < width && rect.width > width) {
                        newX = width - rect.width;
                    }
                    else if (rect.x0 > 0 && rect.width > width) {
                        newX = 0;
                    }
                    
                    // Handle y axis snapping
                    if (rect.y0 < 0 && rect.height - delta <= height) {
                        newY = 0;
                    }
                    else if (rect.y1 > height && rect.height - delta <= height) {
                        newY = height - rect.height;
                    }
                    else if (rect.y1 < height && rect.height > height) {
                        newY = height - rect.height;
                    }
                    else if (rect.y0 > 0 && rect.height > height) {
                        newY = 0;
                    }
                    
                    // Start snap animation
                    var duration = 750;
                    
                    if (newX !== undefined) {
                        this._animator.start('PosX', newX, duration);
                        this._invalidate();
                    }
                    
                    if (newY !== undefined) {
                        this._animator.start('PosY', newY, duration);
                        this._invalidate();
                    }
                },
                
                rotate: function() {
                    this._animator.set('RotationCenterX', this._imageSize[0] * 0.5);
                    this._animator.set('RotationCenterY', this._imageSize[1] * 0.5);
                    var rotation = this._animator.getDestination('Rotation');
                    this._animator.start('Rotation', rotation - Math.PI * 0.5, 500);
                    this._invalidate();
                },
                
                _getImageRect: function() {
                
                    // Make sure the matrices are up-to-date
                    this._updateMatrices();
                    
                    // Compute combined transformation matrix
                    var matrix = IM.Mat3.multiply(this._posMatrix, this._scaleMatrix, this._rotationMatrix);
                    
                    // Find transformed image coordinates (aka. the current position of the image)
                    var tl = IM.Mat3.transformPoint(matrix, 0, 0);
                    var br = IM.Mat3.transformPoint(matrix, this._imageSize[0], this._imageSize[1]);
                    
                    return {x0: tl[0], y0: tl[1], x1: br[0], y1: br[1], width: br[0] - tl[0], height: br[1] - tl[1]};
                },
                
                _resetMatrices: function() {
                
                    // Get image rectangle
                    var rect = this._getImageRect();
                    
                    // Update position matrix
                    this._currentPosX = rect.x0;
                    this._currentPosY = rect.y0;
                    this._animator.set('PosX',  this._currentPosX);
                    this._animator.set('PosY',  this._currentPosY);
                    this._posMatrix = IM.Mat3.makeTranslation(this._currentPosX, this._currentPosY);
                    
                    // Update scale matrix
                    var scale = rect.width / this._imageSize[0];
                    this._currentScale = scale;
                    this._animator.set('Scale', this._currentScale);
                    this._scaleMatrix = IM.Mat3.makeScale(this._currentScale, this._currentScale);
                    
                    // Reset scale center
                    this._animator.set('ScaleCenterX', 0);
                    this._animator.set('ScaleCenterY', 0);
                                        
                    // TODO: Reset rotation matrix + RotationCenterX/Y
                },
                
                _updateMatrices: function() {
                
                    // Create scale delta-matrix
                    var scale = this._animator.get('Scale');
                    var deltaScale = scale / this._currentScale;
                    this._currentScale = scale;
                    var deltaScaleMatrix = IM.Mat3.makeScale(deltaScale, deltaScale);
                    
                    // Create scale-center matrices
                    var scaleCenterX = this._animator.get('ScaleCenterX');
                    var scaleCenterY = this._animator.get('ScaleCenterY');
                    var scaleCenterMatrix = IM.Mat3.makeTranslation(scaleCenterX, scaleCenterY);
                    var scaleCenterInvMatrix = IM.Mat3.invert(scaleCenterMatrix);
                    
                    // Update scale matrix
                    this._scaleMatrix = IM.Mat3.multiply(this._scaleMatrix, scaleCenterMatrix, deltaScaleMatrix, scaleCenterInvMatrix);
                   
                    // Create position delta-matrix
                    var posX = this._animator.get('PosX');
                    var posY = this._animator.get('PosY');
                    var deltaPosX = Math.round(posX - this._currentPosX); // Note: Round the position-delta to nearest pixel - otherwise we get sampling artifacts during motion-animations
                    var deltaPosY = Math.round(posY - this._currentPosY);
                    this._currentPosX = posX;
                    this._currentPosY = posY;
                    var deltaPosMatrix = IM.Mat3.makeTranslation(deltaPosX, deltaPosY);
                    
                    // Update position matrix
                    this._posMatrix = IM.Mat3.multiply(this._posMatrix, deltaPosMatrix);
                    
                    // Create rotation delta-matrix
                    var rotation = this._animator.get('Rotation');
                    var deltaRotation = rotation - this._currentRotation;
                    this._currentRotation = rotation;
                    var deltaRotationMatrix = IM.Mat3.makeRotation(deltaRotation);
                    
                    // Create rotation-center matrices
                    var rotationCenterX = this._animator.get('RotationCenterX');
                    var rotationCenterY = this._animator.get('RotationCenterY');
                    var rotationCenterMatrix = IM.Mat3.makeTranslation(rotationCenterX, rotationCenterY);
                    var rotationCenterInvMatrix = IM.Mat3.invert(rotationCenterMatrix);
                    
                    // Update rotation matrix
                    this._rotationMatrix = IM.Mat3.multiply(this._rotationMatrix, rotationCenterMatrix, deltaRotationMatrix, rotationCenterInvMatrix);
                },
                
                _render: function() {
                    var gl = this._gl;
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    if (this._initialized && this._tiles) {
                        
                        this._updateMatrices();
                        var matrix = IM.Mat3.multiply(this._baseMatrix, this._posMatrix, this._scaleMatrix, this._rotationMatrix);
                        
                        this._program.setUniformMatrix3fv('Matrix', matrix);
                        this._program.setUniform1f('Alpha', this._animator.get('Alpha'));
                        this._program.setUniform1i('Texture', 0);
                        
                        gl.activeTexture(gl.TEXTURE0);
                        
                        for (var i = 0; i < this._tiles.length; i++) {
                            gl.bindTexture(gl.TEXTURE_2D, this._tiles[i]);
                            gl.drawArrays(gl.TRIANGLES, i * 6, 6);
                        }
                    }
                    return this._animator.finished();
                },
            }
            
            
            
            
            //
            // For testing purposes
            //
            var _viewer;
            function init() {          
                var domContainer = document.getElementById('container');
                _viewer = new IM.Viewer(domContainer);
                _viewer.initialize(function() {
                    _viewer.setImage('image.png');
                });
            }
            function zoomToFit() {
                _viewer.zoomToFit(450);
            }
            function rotate() {
                _viewer.rotate();
            }
        
        </script>
    </head>
    
    <body onload='init()'>
        <div id='container'></div>
        <div style='margin: 16px;'>
            <button onclick='zoomToFit()'>Zoom to fit</button>
            <button onclick='rotate()'>Rotate</button>
        </div>
    </body>

</html>